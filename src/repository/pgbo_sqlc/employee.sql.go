// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: employee.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const countEmployee = `-- name: CountEmployee :one
SELECT COUNT(emp.employee_id)
FROM employee emp
WHERE (CASE WHEN $1::bool THEN emp.guid = $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN LOWER(emp.fullname) LIKE LOWER($4) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN LOWER(emp.email) LIKE LOWER($6) ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN TO_CHAR(emp.date_of_birth:: TIMESTAMP, 'DD/MM/YYYY') = TO_CHAR($8:: TIMESTAMP, 'DD/MM/YYYY') ELSE TRUE END)
  AND emp.status != 'deleted'
`

type CountEmployeeParams struct {
	SetGuid        bool      `json:"set_guid"`
	Guid           string    `json:"guid"`
	SetFullname    bool      `json:"set_fullname"`
	Fullname       string    `json:"fullname"`
	SetEmail       bool      `json:"set_email"`
	Email          string    `json:"email"`
	SetDateOfBirth bool      `json:"set_date_of_birth"`
	DateOfBirth    time.Time `json:"date_of_birth"`
}

func (q *Queries) CountEmployee(ctx context.Context, arg CountEmployeeParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countEmployee,
		arg.SetGuid,
		arg.Guid,
		arg.SetFullname,
		arg.Fullname,
		arg.SetEmail,
		arg.Email,
		arg.SetDateOfBirth,
		arg.DateOfBirth,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getEmployee = `-- name: GetEmployee :one
SELECT emp.guid,
       emp.employee_id,
       emp.fullname,
       emp.email,
       emp.phone_number,
       emp.date_of_birth,
       emp.status,
       emp.created_at,
       emp.created_by,
       emp.updated_at,
       emp.updated_by
FROM employee emp
WHERE emp.guid = $1
  AND emp.status != 'deleted'
`

func (q *Queries) GetEmployee(ctx context.Context, guid string) (Employee, error) {
	row := q.db.QueryRowContext(ctx, getEmployee, guid)
	var i Employee
	err := row.Scan(
		&i.Guid,
		&i.EmployeeID,
		&i.Fullname,
		&i.Email,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const insertEmployee = `-- name: InsertEmployee :one
INSERT INTO employee (guid, fullname, email, phone_number, date_of_birth, status, created_at, created_by)
VALUES ($1, $2, $3, $4, $5, $6, (now() at time zone 'UTC'):: TIMESTAMP, $7)
RETURNING employee.guid, employee.employee_id, employee.fullname, employee.email, employee.phone_number, employee.date_of_birth, employee.status, employee.created_at, employee.created_by, employee.updated_at, employee.updated_by
`

type InsertEmployeeParams struct {
	Guid        string         `json:"guid"`
	Fullname    sql.NullString `json:"fullname"`
	Email       string         `json:"email"`
	PhoneNumber sql.NullString `json:"phone_number"`
	DateOfBirth sql.NullTime   `json:"date_of_birth"`
	Status      string         `json:"status"`
	CreatedBy   string         `json:"created_by"`
}

func (q *Queries) InsertEmployee(ctx context.Context, arg InsertEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, insertEmployee,
		arg.Guid,
		arg.Fullname,
		arg.Email,
		arg.PhoneNumber,
		arg.DateOfBirth,
		arg.Status,
		arg.CreatedBy,
	)
	var i Employee
	err := row.Scan(
		&i.Guid,
		&i.EmployeeID,
		&i.Fullname,
		&i.Email,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const listEmployee = `-- name: ListEmployee :many
SELECT emp.guid,
       emp.employee_id,
       emp.fullname,
       emp.email,
       emp.phone_number,
       emp.date_of_birth,
       emp.status,
       emp.created_at,
       emp.created_by,
       emp.updated_at,
       emp.updated_by
FROM employee emp
WHERE (CASE WHEN $1::bool THEN emp.guid = $2 ELSE TRUE END)
  AND (CASE WHEN $3::bool THEN LOWER(emp.fullname) LIKE LOWER($4) ELSE TRUE END)
  AND (CASE WHEN $5::bool THEN LOWER(emp.email) LIKE LOWER($6) ELSE TRUE END)
  AND (CASE WHEN $7::bool THEN TO_CHAR(emp.date_of_birth:: TIMESTAMP, 'DD/MM/YYYY') = TO_CHAR($8:: TIMESTAMP, 'DD/MM/YYYY') ELSE TRUE END)
  AND emp.status != 'deleted'
ORDER BY (CASE WHEN $9 = 'id ASC' THEN emp.employee_id END) ASC,
         (CASE WHEN $9 = 'id DESC' THEN emp.employee_id END) DESC,
         (CASE WHEN $9 = 'guid ASC' THEN emp.guid END) ASC,
         (CASE WHEN $9 = 'guid DESC' THEN emp.guid END) DESC,
         (CASE WHEN $9 = 'fullname ASC' THEN emp.fullname END) ASC,
         (CASE WHEN $9 = 'fullname DESC' THEN emp.fullname END) DESC,
         (CASE WHEN $9 = 'email ASC' THEN emp.email END) ASC,
         (CASE WHEN $9 = 'email DESC' THEN emp.email END) DESC,
         (CASE WHEN $9 = 'phone_number ASC' THEN emp.phone_number END) ASC,
         (CASE WHEN $9 = 'phone_number DESC' THEN emp.phone_number END) DESC,
         (CASE WHEN $9 = 'date_of_birth ASC' THEN emp.date_of_birth END) ASC,
         (CASE WHEN $9 = 'date_of_birth DESC' THEN emp.date_of_birth END) DESC,
         (CASE WHEN $9 = 'created_at ASC' THEN emp.created_at END) ASC,
         (CASE WHEN $9 = 'created_at DESC' THEN emp.created_at END) DESC,
         emp.created_at DESC
LIMIT $11 OFFSET $10
`

type ListEmployeeParams struct {
	SetGuid        bool        `json:"set_guid"`
	Guid           string      `json:"guid"`
	SetFullname    bool        `json:"set_fullname"`
	Fullname       string      `json:"fullname"`
	SetEmail       bool        `json:"set_email"`
	Email          string      `json:"email"`
	SetDateOfBirth bool        `json:"set_date_of_birth"`
	DateOfBirth    time.Time   `json:"date_of_birth"`
	OrderParam     interface{} `json:"order_param"`
	OffsetPage     int32       `json:"offset_page"`
	LimitData      int32       `json:"limit_data"`
}

func (q *Queries) ListEmployee(ctx context.Context, arg ListEmployeeParams) ([]Employee, error) {
	rows, err := q.db.QueryContext(ctx, listEmployee,
		arg.SetGuid,
		arg.Guid,
		arg.SetFullname,
		arg.Fullname,
		arg.SetEmail,
		arg.Email,
		arg.SetDateOfBirth,
		arg.DateOfBirth,
		arg.OrderParam,
		arg.OffsetPage,
		arg.LimitData,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Employee
	for rows.Next() {
		var i Employee
		if err := rows.Scan(
			&i.Guid,
			&i.EmployeeID,
			&i.Fullname,
			&i.Email,
			&i.PhoneNumber,
			&i.DateOfBirth,
			&i.Status,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEmployee = `-- name: UpdateEmployee :one
UPDATE employee
SET fullname        = $1,
    email           = $2,
    phone_number    = $3,
    date_of_birth   = $4,
    updated_at      = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by      = $5
WHERE guid = $6
RETURNING employee.guid, employee.employee_id, employee.fullname, employee.email, employee.phone_number, employee.date_of_birth, employee.status, employee.created_at, employee.created_by, employee.updated_at, employee.updated_by
`

type UpdateEmployeeParams struct {
	Fullname    sql.NullString `json:"fullname"`
	Email       string         `json:"email"`
	PhoneNumber sql.NullString `json:"phone_number"`
	DateOfBirth sql.NullTime   `json:"date_of_birth"`
	UpdatedBy   sql.NullString `json:"updated_by"`
	Guid        string         `json:"guid"`
}

func (q *Queries) UpdateEmployee(ctx context.Context, arg UpdateEmployeeParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, updateEmployee,
		arg.Fullname,
		arg.Email,
		arg.PhoneNumber,
		arg.DateOfBirth,
		arg.UpdatedBy,
		arg.Guid,
	)
	var i Employee
	err := row.Scan(
		&i.Guid,
		&i.EmployeeID,
		&i.Fullname,
		&i.Email,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}

const updateEmployeeStatus = `-- name: UpdateEmployeeStatus :one
UPDATE employee
SET status     = $1,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $2
WHERE guid = $3
  AND status != 'deleted'
RETURNING employee.guid, employee.employee_id, employee.fullname, employee.email, employee.phone_number, employee.date_of_birth, employee.status, employee.created_at, employee.created_by, employee.updated_at, employee.updated_by
`

type UpdateEmployeeStatusParams struct {
	Status    string         `json:"status"`
	UpdatedBy sql.NullString `json:"updated_by"`
	Guid      string         `json:"guid"`
}

func (q *Queries) UpdateEmployeeStatus(ctx context.Context, arg UpdateEmployeeStatusParams) (Employee, error) {
	row := q.db.QueryRowContext(ctx, updateEmployeeStatus, arg.Status, arg.UpdatedBy, arg.Guid)
	var i Employee
	err := row.Scan(
		&i.Guid,
		&i.EmployeeID,
		&i.Fullname,
		&i.Email,
		&i.PhoneNumber,
		&i.DateOfBirth,
		&i.Status,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
	)
	return i, err
}
